# Greedy
그리디 알고리즘은 그 순간에 최적이라고 생각하는 것을 선택하는 것이 결과적인 최적에 도달할 수 있을 때 사용하는 알고리즘이다.   

일반적인 상황에서 그 순간에 최적을 선택하는 것이 최적의 결과를 가져오지 못한다.  

따라서 그리디 알고리즘을 사용하기 위해서는 사용에 대한 정당성을 확보해야 한다.  

밑의 예시들을 보며 이해해보자 

</br>

가장 대표적인 그리디 알고리즘의 문제가 거스름돈 문제이다.  


    890원을 최소한의 동전으로 주려면 어떻게 줄 수 있는가?
    

이 문제가 주어졌을때 대부분 쉽게 답을 구할 수 있다.  

    890 =  500 * 1 + 100 * 3 + 50 * 1 + 10 * 4 이므로 500원 1개, 100원 3개, 50원 1개 10원 4개를 줘야한다.   
값이 큰 동전을 최대한으로 주는 것이 좋을 것 같다고 생각했고 그리고 실제로 답이 맞다  
</br>
하지만 만약 기존의 동전에 400원짜리가 존재한다고 하면 어떨까?  

    890 = 400 * 2 +  50 * 1 + 10 * 4 이므로 400원 2개, 50원 1개 10원 4개를 줘야한다. 

위에서와는 답이 달라졌다. 값이 큰 동전을 최대한으로 주는 것보다, 500원짜리 동전을 포기하고 400원짜리 동전을 2개 선택하는 것이 최적의 결과를 가져온다.  
즉 그리디 알고리즘을 사용할 수없었다.  

왜 위에서는 그리디 알고리즘의 사용이 가능하고 밑에서는 불가능했을까?  

위의 경우 동전들 끼리 약수 배수의 관계를 이루고 있다.  
하지만 밑에서는 400원 짜리 동전은 500원 짜리 동전의 약수가 되지 않는다.  
약수가 될 때는 작은 단위의 동전을 사용하는것 보다 합쳐서 큰단위 동전을 사용할 수 있다면 큰 단위 동전을 최대한으로 만드는 것이 무조건 유리하다고 할 수 있다. 하지만 약수 배수의 관계를 이루지 않을 때는 그렇지 않다.  

</br>
</br>

다음 문제를 보자.

    N, K가 주어지고 두 과정중 하나를 반복적으로 수행한다.  
    1)N에서 1을 뺀다.   
    2)N을 K로 나눈다.  
    N이 1이 될 때까지 최소한의 수행을 하려고 할 때 어떻게 하면 되겠는가?

N을 K로 나누는 과정을 많이 하는 것이 유리하겠다는 생각은 들고 실제로도 그렇다.  
쉬운 문제지만 '이렇게 푸는 것이 확실한가?'라고 생각해볼 필요는 있다.  

    1) N - 1
    2) N / K
   
    1번의 과정이 2번보다 큰 경우가 있다는 것은 다음 부등식을 만족한다는 것이다.
    N-1 > N/K
    이 식을 바꿔보면 
    K < N/(N-1)
    를 만족해야 한다.

    하지만 이를 만족하는 경우는 K = 1 말고는 없다.

위와 같이 2)의 과정을 최대한으로 많이 진행하는 것이 좋다는 것에 대한 정당성을 확보 할 수 있다.


</br>
</br>

# 정리
별로 어렵지 않은 내용이다.  
매순간 그 때의 최적을 챙기는 것이 결과적인 최적이 될 수 있는지에 대한 생각이 필요하다.  
언제 Greedy 알고리즘을 사용할 수 있는지, 그때 그것이 최적임이 어떻게 보장할 수 있는지에 대해서는 조금 깊게 생각해볼 필요가 있다.
